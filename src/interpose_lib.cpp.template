#ifdef __cplusplus
extern "C" {
#endif

#include "{{ORIGINAL_HEADER}}"

#ifdef __cplusplus
}
#endif

#include <cstdio>
#include <dlfcn.h>

#ifdef USE_CHRONO
#include <chrono>
#else
#include <sys/time.h>
#endif

// insert the user-defined functions
#include "{{USER_DEFINED_FUNCTIONS}}"

namespace util
{
#ifdef __APPLE__
   // retrieving the original function call on OS X requires the library name
   static const char LIB_NAME[] = "{{APPLE_LIB_NAME}}";
#endif

#ifndef USE_CHRONO
   typedef long long unsigned llu;

   static auto current_time() -> timeval
   {
      // store a precise time-stamp
      timeval time;

      // capture the current time
      gettimeofday(&time, NULL);

      // return the time
      return time;
   }

   static void print_call(timeval const &call, char const *function)
   {
      printf
      (
         "[%011llu.%06llu][call] %s()\n",
         static_cast<llu>(call.tv_sec),
         static_cast<llu>(call.tv_usec),
         function
      );
   }

   static void print_done(timeval const &call, timeval const &done, char const *function)
   {
      long long unsigned diff = 
         (static_cast<llu>(done.tv_sec) * 1000000ull + static_cast<llu>(done.tv_usec)) -
         (static_cast<llu>(call.tv_sec) * 1000000ull + static_cast<llu>(call.tv_usec));

      printf
      (
         "[%011llu.%06llu][done][%llu.%06llu] %s()\n",
         static_cast<llu>(done.tv_sec),
         static_cast<llu>(done.tv_usec),
         diff / 1000000ull,
         diff % 1000000ull,
         function
      );
   }
#endif

   template<typename Signature>
   static auto get_function(char const *function) -> Signature
   {
#ifdef __APPLE__
      /** 
       ** On OS X, the original library is loaded explicitly and the function is
       ** queried from within that library. This technique does not work on linux; it
       ** results in an infinite recursion.
       **/

      // grab handle to the original library
      void *handle = dlopen(LIB_NAME, RTLD_NOW);

      // find the original function within that library
      return reinterpret_cast<Signature>(dlsym(handle, function));
#else
      /** 
       ** Retrieving a pointer to the original function is even easier in linux. It
       ** doesn't even require the original library name. Calling dlsym() with the
       ** flag "RTLD_NEXT" returns the *next* occurrence of the specified name, which
       ** is the original library call. This does not work on OS X; it fails to find
       ** the function.
       **/

      // find the original function
      return reinterpret_cast<Signature>(dlsym(RTLD_NEXT, function));
#endif
   }

   template<typename ReturnType, typename...Parameters>
   static auto interpose
   (
      ReturnType (*wrap)(ReturnType (*)(Parameters...), Parameters...),
      char const *function_name,
      ReturnType (*&original)(Parameters...),
      ReturnType const &default_return,
      Parameters...parameters
   )
   -> ReturnType
   {
#ifdef USE_CHRONO
      // duration, duration_cast, high_resolution_clock
      using namespace std::chrono;

      // used when outputting the current (or elapsed) time in seconds
      typedef duration<double> seconds;

      // record the timestamp before the call
      auto call(high_resolution_clock::now());

      // print the time-stamp
      printf("[%017.6f][call] %s()\n", duration_cast<seconds>(call.time_since_epoch()).count(), function_name);
#else
      // record the timestamp before the call
      auto call(current_time());

      // print the time-stamp
      print_call(call, function_name);
#endif

      // find the original function
      if(!original)
      {
         original = get_function<ReturnType (*)(Parameters...)>(function_name);

         // if the original function is not found...
         if(!original)
         {
            // ...print an error...
            printf("   >>> ERROR: %s() not found\n", function_name);

            // ...and return immediately
            return default_return;
         }
      }

      // run the original function
      ReturnType result(wrap(original, parameters...));

#ifdef USE_CHRONO
      // record the timestamp after the call
      auto done(high_resolution_clock::now());

      // print the time-stamp and duration
      printf
      (
         "[%017.6f][done][%08.6f] %s()\n",
         duration_cast<seconds>(done.time_since_epoch()).count(),
         duration_cast<seconds>(done - call).count(),
         function_name
      );
#else
      // record the timestamp after the call
      auto done(current_time());

      // print the time-stamp and duration
      print_done(call, done, function_name);
#endif

      // return the actual result
      return result;
   }

   template<typename...Parameters>
   static void interpose
   (
      void (*wrap)(void (*)(Parameters...), Parameters...),
      char const *function_name,
      void (*&original)(Parameters...),
      Parameters...parameters
   )
   {
#ifdef USE_CHRONO
      // duration, duration_cast, high_resolution_clock
      using namespace std::chrono;

      // used when outputting the current (or elapsed) time in seconds
      typedef duration<double> seconds;

      // record the timestamp before the call
      auto call(high_resolution_clock::now());

      // print the time-stamp
      printf("[%017.6f][call] %s()\n", duration_cast<seconds>(call.time_since_epoch()).count(), function_name);
#else
      // record the timestamp before the call
      auto call(current_time());

      // print the time-stamp
      print_call(call, function_name);
#endif

      // find the original function
      if(!original)
      {
         original = get_function<void (*)(Parameters...)>(function_name);

         // if the original function is not found...
         if(!original)
         {
            // ...print an error...
            printf("   >>> ERROR: %s() not found\n", function_name);

            // ...and return immediately
            return;
         }
      }

      // run the original function
      wrap(original, parameters...);

#ifdef USE_CHRONO
      // record the timestamp after the call
      auto done(high_resolution_clock::now());

      // print the time-stamp and duration
      printf
      (
         "[%017.6f][done][%08.6f] %s()\n",
         duration_cast<seconds>(done.time_since_epoch()).count(),
         duration_cast<seconds>(done - call).count(),
         function_name
      );
#else
      // record the timestamp after the call
      auto done(current_time());

      // print the time-stamp and duration
      print_done(call, done, function_name);
#endif
   }
}

{{FOR_EACH_FUNCTION:
static auto proxy_{{NAME}}({{ARGUMENT_LIST}}) -> {{RETURN_TYPE}}
{
   // points to the original function being interposed
   static {{RETURN_TYPE}} (*original)({{ARGUMENT_TYPES}}) = NULL;
   {{IF_NONVOID:
   // typedef the return type so that the default constructor can be used for pointer types also
   typedef {{RETURN_TYPE}} {{NAME}}_return_type;
   }}
   // call the generic interposing function to handle the details
   {{IF_NONVOID:return }}util::interpose(&{{NAME}}, "{{NAME}}", original{{IF_NONVOID:, {{NAME}}_return_type()}}{{,ARGUMENT_NAMES}});
}
}}

#ifdef __cplusplus
extern "C" {
#endif

{{FOR_EACH_FUNCTION:
{{RETURN_TYPE}} {{NAME}}({{ARGUMENT_LIST}})
{
   {{IF_NONVOID:return }}proxy_{{NAME}}({{ARGUMENT_NAMES}});
}
}}

#ifdef __cplusplus
}
#endif
