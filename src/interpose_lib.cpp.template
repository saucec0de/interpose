#ifdef __cplusplus
extern "C" {
#endif

#include <dlfcn.h>
#include "{{ORIGINAL_HEADER}}"

#ifdef __cplusplus
}
#endif

#include <cstdio>
#include <chrono>

// insert the user-defined functions
#include "{{USER_DEFINED_FUNCTIONS}}"

namespace util
{
#ifdef __APPLE__
   // retrieving the original function call on OS X requires the library name
   static const char LIB_NAME[] = "{{APPLE_LIB_NAME}}";
#endif

   template<typename Signature>
   static auto get_function(char const *function) -> Signature
   {
#ifdef __APPLE__
      /** 
       ** On OS X, the original library is loaded explicitly and the function is
       ** queried from within that library. This technique does not work on linux; it
       ** results in an infinite recursion.
       **/

      // grab handle to the original library
      void *handle = dlopen(LIB_NAME, RTLD_NOW);

      // find the original function within that library
      return (Signature)dlsym(handle, function);
#else
      /** 
       ** Retrieving a pointer to the original function is even easier in linux. It
       ** doesn't even require the original library name. Calling dlsym() with the
       ** flag "RTLD_NEXT" returns the *next* occurrence of the specified name, which
       ** is the original library call. This does not work on OS X; it fails to find
       ** the function.
       **/

      // find the original function
      return (Signature)dlsym(RTLD_NEXT, function);
#endif
   }

   template<typename ReturnType, typename...Parameters>
   static auto interpose
   (
      ReturnType (*wrap)(ReturnType (*)(Parameters...), Parameters...),
      char const *function_name,
      ReturnType (*&original)(Parameters...),
      ReturnType const &default_return,
      Parameters...parameters
   )
   -> ReturnType
   {
      // duration, duration_cast, high_resolution_clock
      using namespace std::chrono;

      // used when outputting the current (or elapsed) time in seconds
      typedef duration<double> seconds;

      // record the timestamp before the call
      auto call(high_resolution_clock::now());

      // print the time-stamp
      printf("[%017.6f][call] %s()\n", duration_cast<seconds>(call.time_since_epoch()).count(), function_name);

      // find the original function
      if(!original)
      {
         original = get_function<ReturnType (*)(Parameters...)>(function_name);

         // if the original function is not found...
         if(!original)
         {
            // ...print an error...
            printf("   >>> ERROR: %s() not found\n", function_name);

            // ...and return immediately
            return default_return;
         }
      }

      // run the original function
      ReturnType result(wrap(original, parameters...));

      // record the timestamp after the call
      auto done(high_resolution_clock::now());

      // print the time-stamp
      printf
      (
         "[%017.6f][done][%08.6f] %s()\n",
         duration_cast<seconds>(done.time_since_epoch()).count(),
         duration_cast<seconds>(done - call).count(),
         function_name
      );

      // return the actual result
      return result;
   }

   template<typename...Parameters>
   static void interpose
   (
      void (*wrap)(void (*)(Parameters...), Parameters...),
      char const *function_name,
      void (*&original)(Parameters...),
      Parameters...parameters
   )
   {
      // duration, duration_cast, high_resolution_clock
      using namespace std::chrono;

      // used when outputting the current (or elapsed) time in seconds
      typedef duration<double> seconds;

      // record the timestamp before the call
      auto call(high_resolution_clock::now());

      // print the time-stamp
      printf("[%017.6f][call] %s()\n", duration_cast<seconds>(call.time_since_epoch()).count(), function_name);

      // find the original function
      if(!original)
      {
         original = get_function<void (*)(Parameters...)>(function_name);

         // if the original function is not found...
         if(!original)
         {
            // ...print an error...
            printf("   >>> ERROR: %s() not found\n", function_name);

            // ...and return immediately
            return;
         }
      }

      // run the original function
      wrap(original, parameters...);

      // record the timestamp after the call
      auto done(high_resolution_clock::now());

      // print the time-stamp
      printf
      (
         "[%017.6f][done][%08.6f] %s()\n",
         duration_cast<seconds>(done.time_since_epoch()).count(),
         duration_cast<seconds>(done - call).count(),
         function_name
      );
   }
}

{{FOR_EACH_FUNCTION:
static auto proxy_{{NAME}}({{ARGUMENT_LIST}}) -> {{RETURN_TYPE}}
{
   // points to the original function being interposed
   static {{RETURN_TYPE}} (*original)({{ARGUMENT_TYPES}}) = NULL;
   {{IF_NONVOID:
   // typedef the return type so that the default constructor can be used for pointer types also
   typedef {{RETURN_TYPE}} {{NAME}}_return_type;
   }}
   // call the generic interposing function to handle the details
   {{IF_NONVOID:return }}util::interpose(&{{NAME}}, "{{NAME}}", original{{IF_NONVOID:, {{NAME}}_return_type()}}{{,ARGUMENT_NAMES}});
}
}}

#ifdef __cplusplus
extern "C" {
#endif

{{FOR_EACH_FUNCTION:
{{RETURN_TYPE}} {{NAME}}({{ARGUMENT_LIST}})
{
   {{IF_NONVOID:return }}proxy_{{NAME}}({{ARGUMENT_NAMES}});
}
}}

#ifdef __cplusplus
}
#endif
